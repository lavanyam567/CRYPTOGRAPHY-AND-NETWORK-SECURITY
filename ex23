/* COUNTER (CTR) MODE ENCRYPTION & DECRYPTION USING S-DES
   Cipher: S-DES
   Mode  : Counter Mode (CTR)

   Test Data (given):
   Counter start : 00000000
   Plaintext     : 00000001 00000010 00000100
   Key           : 0111111101
   Ciphertext    : 00111000 01001111 00110010
*/

#include <stdio.h>
#include <string.h>

/* ---------- S-DES TABLES ---------- */
int P10[] = {3,5,2,7,4,10,1,9,8,6};
int P8[]  = {6,3,7,4,8,5,10,9};
int IP[]  = {2,6,3,1,4,8,5,7};
int IP_INV[] = {4,1,3,5,7,2,8,6};
int EP[]  = {4,1,2,3,2,3,4,1};
int P4[]  = {2,4,3,1};

int S0[4][4] = {
    {1,0,3,2},{3,2,1,0},{0,2,1,3},{3,1,3,2}
};
int S1[4][4] = {
    {0,1,2,3},{2,0,1,3},{3,0,1,0},{2,1,0,3}
};

/* ---------- UTILITIES ---------- */
void permute(int *in, int *out, int *p, int n) {
    for(int i=0;i<n;i++) out[i]=in[p[i]-1];
}

void left_shift(int *k, int s) {
    while(s--) {
        int t=k[0];
        for(int i=0;i<4;i++) k[i]=k[i+1];
        k[4]=t;
    }
}

void xor(int *a, int *b, int n) {
    for(int i=0;i<n;i++) a[i]^=b[i];
}

/* ---------- KEY GENERATION ---------- */
void generate_keys(int *key, int *K1, int *K2) {
    int p10[10];
    permute(key,p10,P10,10);

    left_shift(p10,1);
    left_shift(p10+5,1);
    permute(p10,K1,P8,8);

    left_shift(p10,2);
    left_shift(p10+5,2);
    permute(p10,K2,P8,8);
}

/* ---------- ROUND FUNCTION ---------- */
void fk(int *L, int *R, int *K) {
    int ep[8], t[8], out[4];
    permute(R,ep,EP,8);
    memcpy(t,ep,8*sizeof(int));
    xor(t,K,8);

    int r = t[0]*2 + t[3], c = t[1]*2 + t[2];
    out[0]=(S0[r][c]>>1)&1; out[1]=S0[r][c]&1;

    r = t[4]*2 + t[7]; c = t[5]*2 + t[6];
    out[2]=(S1[r][c]>>1)&1; out[3]=S1[r][c]&1;

    permute(out,out,P4,4);
    xor(L,out,4);
}

/* ---------- S-DES ENCRYPT ---------- */
void sdes_encrypt(int *pt, int *ct, int *K1, int *K2) {
    int ip[8], L[4], R[4];
    permute(pt,ip,IP,8);
    memcpy(L,ip,4*sizeof(int));
    memcpy(R,ip+4,4*sizeof(int));

    fk(L,R,K1);
    fk(R,L,K2);

    int pre[8];
    memcpy(pre,R,4*sizeof(int));
    memcpy(pre+4,L,4*sizeof(int));
    permute(pre,ct,IP_INV,8);
}

/* ---------- CTR MODE ---------- */
void ctr_mode(int pt[][8], int ct[][8], int blocks,
              int *counter, int *K1, int *K2) {
    int stream[8];
    for(int i=0;i<blocks;i++) {
        sdes_encrypt(counter,stream,K1,K2);
        memcpy(ct[i],pt[i],8*sizeof(int));
        xor(ct[i],stream,8);

        /* increment counter */
        for(int j=7;j>=0;j--) {
            if(counter[j]==0){ counter[j]=1; break; }
            counter[j]=0;
        }
    }
}

/* ---------- MAIN ---------- */
int main() {
    int key[10]={0,1,1,1,1,1,1,1,0,1};
    int counter[8]={0,0,0,0,0,0,0,0};

    int plaintext[3][8]={
        {0,0,0,0,0,0,0,1},
        {0,0,0,0,0,0,1,0},
        {0,0,0,0,0,1,0,0}
    };

    int ciphertext[3][8], decrypted[3][8];
    int K1[8],K2[8];

    generate_keys(key,K1,K2);

    ctr_mode(plaintext,ciphertext,3,counter,K1,K2);

    int counter2[8]={0,0,0,0,0,0,0,0};
    ctr_mode(ciphertext,decrypted,3,counter2,K1,K2);

    printf("Ciphertext:\n");
    for(int i=0;i<3;i++){
        for(int j=0;j<8;j++) printf("%d",ciphertext[i][j]);
        printf(" ");
    }

    printf("\nDecrypted Plaintext:\n");
    for(int i=0;i<3;i++){
        for(int j=0;j<8;j++) printf("%d",decrypted[i][j]);
        printf(" ");
    }

    return 0;
}
