/* CBC MODE ENCRYPTION & DECRYPTION USING S-DES
   Cipher chosen: S-DES (Simple DES)
   Mode: CBC (Cipher Block Chaining)

   Test vector (as given):
   IV        = 10101010
   Plaintext = 00000001 00100011
   Key       = 0111111101
   Ciphertext expected = 11110100 00001011
*/

#include <stdio.h>
#include <string.h>

/* ---------- S-DES TABLES ---------- */
int P10[] = {3,5,2,7,4,10,1,9,8,6};
int P8[]  = {6,3,7,4,8,5,10,9};
int IP[]  = {2,6,3,1,4,8,5,7};
int IP_INV[] = {4,1,3,5,7,2,8,6};
int EP[]  = {4,1,2,3,2,3,4,1};
int P4[]  = {2,4,3,1};

int S0[4][4] = {
    {1,0,3,2},{3,2,1,0},{0,2,1,3},{3,1,3,2}
};
int S1[4][4] = {
    {0,1,2,3},{2,0,1,3},{3,0,1,0},{2,1,0,3}
};

/* ---------- UTILITIES ---------- */
void permute(int *in, int *out, int *p, int n) {
    for(int i=0;i<n;i++) out[i]=in[p[i]-1];
}

void left_shift(int *key, int shifts) {
    while(shifts--) {
        int t = key[0];
        for(int i=0;i<4;i++) key[i]=key[i+1];
        key[4]=t;
    }
}

void xor(int *a, int *b, int n) {
    for(int i=0;i<n;i++) a[i]^=b[i];
}

/* ---------- KEY GENERATION ---------- */
void generate_keys(int *key, int *K1, int *K2) {
    int p10[10];
    permute(key,p10,P10,10);

    left_shift(p10,1);
    left_shift(p10+5,1);
    permute(p10,K1,P8,8);

    left_shift(p10,2);
    left_shift(p10+5,2);
    permute(p10,K2,P8,8);
}

/* ---------- ROUND FUNCTION ---------- */
void fk(int *L, int *R, int *K) {
    int ep[8], temp[8], out[4];
    permute(R,ep,EP,8);
    memcpy(temp,ep,sizeof(temp));
    xor(temp,K,8);

    int row = temp[0]*2 + temp[3];
    int col = temp[1]*2 + temp[2];
    out[0] = (S0[row][col]>>1)&1;
    out[1] = S0[row][col]&1;

    row = temp[4]*2 + temp[7];
    col = temp[5]*2 + temp[6];
    out[2] = (S1[row][col]>>1)&1;
    out[3] = S1[row][col]&1;

    permute(out,out,P4,4);
    xor(L,out,4);
}

/* ---------- S-DES ENCRYPT / DECRYPT ---------- */
void sdes(int *pt, int *ct, int *K1, int *K2, int decrypt) {
    int ip[8], L[4], R[4];
    permute(pt,ip,IP,8);
    memcpy(L,ip,4*sizeof(int));
    memcpy(R,ip+4,4*sizeof(int));

    if(!decrypt){ fk(L,R,K1); fk(R,L,K2); }
    else        { fk(L,R,K2); fk(R,L,K1); }

    int preout[8];
    memcpy(preout,R,4*sizeof(int));
    memcpy(preout+4,L,4*sizeof(int));
    permute(preout,ct,IP_INV,8);
}

/* ---------- CBC MODE ---------- */
void cbc_encrypt(int pt[][8], int ct[][8], int blocks, int *iv, int *K1, int *K2) {
    int temp[8];
    for(int i=0;i<blocks;i++){
        memcpy(temp,pt[i],8*sizeof(int));
        xor(temp,iv,8);
        sdes(temp,ct[i],K1,K2,0);
        memcpy(iv,ct[i],8*sizeof(int));
    }
}

void cbc_decrypt(int ct[][8], int pt[][8], int blocks, int *iv, int *K1, int *K2) {
    int temp[8], prev[8];
    for(int i=0;i<blocks;i++){
        memcpy(prev,ct[i],8*sizeof(int));
        sdes(ct[i],temp,K1,K2,1);
        xor(temp,iv,8);
        memcpy(pt[i],temp,8*sizeof(int));
        memcpy(iv,prev,8*sizeof(int));
    }
}

/* ---------- MAIN ---------- */
int main() {
    int key[10] = {0,1,1,1,1,1,1,1,0,1};
    int iv[8]   = {1,0,1,0,1,0,1,0};

    int plaintext[2][8] = {
        {0,0,0,0,0,0,0,1},
        {0,0,1,0,0,0,1,1}
    };

    int ciphertext[2][8], decrypted[2][8];
    int K1[8], K2[8];

    generate_keys(key,K1,K2);
    cbc_encrypt(plaintext,ciphertext,2,iv,K1,K2);

    int iv2[8] = {1,0,1,0,1,0,1,0};
    cbc_decrypt(ciphertext,decrypted,2,iv2,K1,K2);

    printf("CBC Encryption Result:\n");
    for(int i=0;i<2;i++){
        for(int j=0;j<8;j++) printf("%d",ciphertext[i][j]);
        printf(" ");
    }

    printf("\nCBC Decryption Result:\n");
    for(int i=0;i<2;i++){
        for(int j=0;j<8;j++) printf("%d",decrypted[i][j]);
        printf(" ");
    }

    return 0;
}
